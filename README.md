# OODA Agent ERC

Экспериментальный агент для ERC3 challenge, сфокусированный на скорости инференса и выполнения задач.

Реализует архитектуру **OODA Loop (Observe-Orient-Decide-Act)** с использованием **Cerebras** (через OpenRouter) для скорости.

## Результаты и метрики

Агент не претендует на идеальную точность, его главная фишка — скорость реакции.

**Speed Leaderboard:** #4 место ([таблица](https://erc.timetoact-group.at/assets/erc3.html#speed))
- **Время на задачу:** ~10 сек
- **Score:** ~0.350

**Locality Leaderboard:** #5 место ([таблица](https://erc.timetoact-group.at/assets/erc3.html#locality))
- **Время:** ~11 сек
- **Score:** ~0.320

Статья “[ERC3 | Путь Qwen-агента на 4ое место по скорости в ERC3](https://telegra.ph/ERC3--Put-Qwen-agenta-na-4oe-mesto-po-skorosti-v-ERC3-12-16)” (как это было сделано).

*Примечание: Агент оптимизирован для быстрого прохождения простых и средних сценариев. В сложных кейсах возможны галлюцинации или ошибки логики в угоду скорости.*

## Основные особенности

- **Инференс через Cerebras:** Основная модель (по умолчанию) — `qwen/qwen3-235b-a22b-2507` (OpenRouter provider preference: Cerebras). Это обеспечивает высокую скорость генерации.
- **Архитектура OODA:** Четкое разделение на фазы наблюдения, ориентации, решения и действия в каждом шаге.
- **Structured Outputs:** Использование Pydantic для жесткой структуры ответа (мысли, черновик, память, вызов функции).
- **Агрессивное управление контекстом:** Память постоянно сжимается, оставляя только критически важные ID и факты, чтобы не перегружать контекст и не замедлять генерацию.

## Требования

- Python 3.10+
- **OpenRouter API Key** (обязательно)

## Установка

```bash
pip install -r requirements.txt
```

Создайте файл `.env`:
```bash
OPENROUTER_API_KEY=your_key_here
```

## Использование

### Быстрый старт

Запуск агента (по умолчанию использует многопоточность):

```bash
# Из папки проекта
python main.py
```

### Параметры

- `-b, --benchmark`: `dev` (по умолчанию), `test`, `prod`.
- `-t, --task`: Запуск конкретных задач (например, `-t 1 -t add_time_entry`).
- `-m, --model`: Выбор модели. По умолчанию `qwen` (Cerebras). Доступны: `grok`, `grok-fast`, `gpt`.
- `-w, --workers`: Количество потоков (по умолчанию 5).
- `--sequential`: Последовательный режим (для отладки).

Примеры:
```bash
# Запуск конкретной задачи на быстрой модели
python main.py -t 1 -m qwen -b dev

# Последовательный прогон для детального лога
python main.py --sequential
```

## Архитектура (в деталях)

Проект использует цикл OODA для принятия решений.

1. **Observe:** Получение данных от API.
2. **Orient:** Сборка динамического промпта. В промпт вшиты эвристики поиска ("Search Ladders") — если точный поиск не дал результатов, агент пробует искать по частичным совпадениям (например, "Danmark" -> "DK").
3. **Decide:** Генерация следующего шага.
4. **Act:** Вызов API.

### Защитные механизмы (Simple Guardrails)

Чтобы агент не "улетел" в галлюцинации из-за высокой скорости:
- **Regex-фильтры:** Блокируют вопросы о зарплатах и попытки вайпа данных до обращения к LLM.
- **Проверка ID (эвристика):** Перед вызовом API применяется анти-галлюцинационная эвристика: блокируются *очевидно фейковые* шаблоны ID (например, числовые `proj_105`, `emp_1`). Это не строгая проверка “ID точно был получен ранее из API”: правдоподобный, но выдуманный ID теоретически может пройти, если не попадает под эвристику.
- **Проверка действий:** Нельзя сказать "Готово", если в задаче требовалось изменение данных, а вызова API не было.

### Структура проекта

```
ooda_agent_erc/
├── agent.py             # Логика OODA цикла
├── config.py            # Настройки моделей
├── main.py              # Запуск и аргументы CLI
├── task_logs/           # Логи выполнения
└── requirements.txt     # Зависимости
```

## Известные ограничения

1. **Точность:** Из-за фокуса на скорость агент может пропускать нюансы в сложных, многоходовых задачах.
2. **Лимиты API:** Везде используется жесткий `limit=5` для списков, чтобы не забивать контекст.
3. **Память:** "Long-term memory" реализована через агрессивное сжатие логов. Если задача требует помнить деталь 30 шагов назад, она может быть утеряна.

## Лицензия

MIT